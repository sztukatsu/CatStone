import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.imageio.ImageIO;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.border.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import java.awt.*;
import java.awt.image.*;
import java.awt.color.*;

import javax.swing.*;

import java.awt.event.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.security.GeneralSecurityException;
import java.util.Arrays;
import java.util.Random;
public class Goo {
	private JFrame frame;
	private JPasswordField pass1,pass2;
	private JTextField hostSize;
	private JTextField targetSize;
	private JFileChooser fc;
	private BufferedImage one,two;
	private String size1,size2;
	private int offset;
	private JSlider noise;
	private String log;
	private JPanel image;
	private String targetdata;
    private byte[] salt ={
        (byte) 0x43, (byte) 0x76, (byte) 0x95, (byte) 0xc7,
        (byte) 0x5b, (byte) 0xd7, (byte) 0x45, (byte) 0x17};
    private JTextField txtSeed;
    private BufferedImage finalp;
    private int seed;
    private JTextArea output;
    private JTextField capacity;
    private int cap;
	
    //the constructor main and initialize method were auto generated by the eclipse windowbuilder app
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					Goo window = new Goo();
					window.frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}
	
	//i did not write this.. but it's needed so windowbuilder works.
	public Goo() {
		initialize();
	}
	
	//this takes a number of bytes, usually a very big number, and converts it into human readable form, like kb, mb, gb
	public static String ByteCount(long bytes) {
	    int unit = 1000;
	    if (bytes < unit) return bytes + " B";
	    int exp = (int) (Math.log(bytes) / Math.log(unit));
	    String pre = String.valueOf(("kMGTPE").charAt(exp-1));
	    return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);
	}
	
	//i take an image and scale it down so i can be displayed within the jpanel. the cool bit is that i can compensate for images
	//that are wider than tall and vice versa.
	public void scaleImage(BufferedImage img) {
		image.removeAll();
		image.updateUI();
	    int original_width = img.getWidth();
	    int original_height = img.getHeight();
	    int bound_width = image.getWidth()-20;
	    int bound_height = image.getHeight()-34;
	    int new_width = original_width;
	    int new_height = original_height;
	    if (original_width > bound_width) {
	        new_width = bound_width;
	        new_height = (new_width * original_height) / original_width;
	    }
	    if (new_height > bound_height) {
	        new_height = bound_height;
	        new_width = (new_height * original_width) / original_height;
	    }
	    Image scaledImage = img.getScaledInstance(new_width,new_height,Image.SCALE_SMOOTH);
        JLabel scaled = new JLabel(new ImageIcon(scaledImage));
        image.add(scaled, BorderLayout.CENTER);
        image.revalidate();
        image.repaint();
	}
	
	//i add noise to the image based on the slider inputs. rgb values out of bounds are set at 0 and 255
	public void addNoise(){
		if(one!=null){
		int w = one.getWidth();
		int h = one.getHeight(null);
		int[] pixels = new int[w*h];
		int[] pixels2 = new int[w*h];
		one.getRGB(0, 0, w, h, pixels, 0, w);
		for(int i= 0; i< pixels.length; i++){
			Random rand = new Random();
			int pixel = pixels[i];
			int o1 = rand.nextInt(10*offset+1)-5*offset+1;
			int o2 = rand.nextInt(10*offset+1)-5*offset+1;
			int o3 = rand.nextInt(10*offset+1)-5*offset+1;
			int b = pixel & 0xff;
			int g = (pixel & 0xff00) >> 8;
			int r = (pixel & 0xff0000) >> 16;
			r+=o1;b+=o2;g+=o3;
	        if(r>252){r=252;}if(r<0){r=0;}
	        if(g>252){g=252;}if(g<0){g=0;}
	        if(b>252){b=252;}if(b<0){b=0;}
	        Color color = new Color((int)r,(int)g,(int)b);
	        int rgb = color.getRGB(); 
	        pixels2[i] = rgb;
		}
		two = new BufferedImage( w, h, BufferedImage.TYPE_INT_ARGB );
		final int[] a = ( (DataBufferInt)two.getRaster().getDataBuffer() ).getData();
		System.arraycopy(pixels2, 0, a, 0, pixels2.length);
		scaleImage(two);
	}
	}
	
	// my job is to convert byte[] data from files into 8bit, so its easier to get the least significant bit
	// i save them as strings to preserve the 000's in the front. for some weird reason it adds a bunch of 1's in the front, so i have to substring it.
	public String[] toBin(byte[] dat){
		String[] bin = new String[dat.length];
		for(int i=0; i<dat.length; i++){
            String s = "0000000" + Integer.toBinaryString(dat[i]);
            s = s.substring(s.length() - 8); 
            bin[i]=s;
		}
		return bin;
	}
	
	//so this is the method responsible for steganography. i take an image and convert it into an array of rgb values. the target data i would like to hide is turned
	//into a bytestream, and i insert each byte into the bgr values of the host image. i then rebuild the host image, which then has the target data hidden.
	public void hideCat(String password1, String password2) throws IOException, GeneralSecurityException{
		if(password1.equals(password2)){
			if(one!=null){
				if(two!=null){
					seed = 0;
					int[] pixels = new int[one.getWidth()*one.getHeight()];
					int[] pixels2 = new int[one.getWidth()*one.getHeight()];
					one.getRGB(0, 0,one.getWidth(),one.getHeight(), pixels, 0, one.getWidth());
					byte[] encData = encryptFile(targetdata, password1);
					String[] encData2 = toBin(encData);
					int max = encData2.length*8;
					for(int i=0; i<pixels.length; i++){
						String b = "0000000" + Integer.toBinaryString(pixels[i] & 0xff);
						String g = "0000000" + Integer.toBinaryString((pixels[i] & 0xff00) >> 8);
						String r = "0000000" + Integer.toBinaryString((pixels[i] & 0xff0000) >> 16);
						if(seed<max){
							b = b.substring(b.length() - 8); 
							g = g.substring(g.length() - 8); 
							r = r.substring(r.length() - 8);
							if(seed<max){
								b = b.substring(0,7)+encData2[seed/8].substring((seed%8),seed%8+1);
								seed++;
							}
						 	if(seed<max){
								g = g.substring(0,7)+encData2[seed/8].substring((seed%8),seed%8+1);
						 		seed++;
							}
							if(seed<max){
								r = r.substring(0,7)+encData2[seed/8].substring((seed%8),seed%8+1);
								seed++;
							}
						}
						Color color = new Color(Integer.parseInt(r,2),Integer.parseInt(g,2),Integer.parseInt(b,2));			
				        int rgb = color.getRGB(); 
				        pixels2[i] = rgb;
					}
					finalp= new BufferedImage(one.getWidth(),one.getHeight(), BufferedImage.TYPE_INT_ARGB );
					final int[] a = ( (DataBufferInt)finalp.getRaster().getDataBuffer() ).getData();
					System.arraycopy(pixels2, 0, a, 0, pixels2.length);
					scaleImage(finalp);
					txtSeed.setText("Seed:   "+Integer.toString(seed));
				}
				else{
					log+="\nPlease select a target file to hide";
				}
			}
			else{
				log+="\nPlease select a host image";
			}
		}
		else{
			log+="\nPasswords do not match";
		}
	output.setText(log);
	}
	
	//ohmygod this method was disgusting. i learned alot of encryption. the funny thing is that i remade the a dozen times because the decrypted data was rubbish,
	//it turned out that the algorithm i used generated assymetrical keys, which made passwords inconsistant. i fixed that
	 private Cipher makeCipher(String pass) throws GeneralSecurityException{
	        PBEKeySpec keySpec = new PBEKeySpec(pass.toCharArray());
	        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
	        SecretKey key = keyFactory.generateSecret(keySpec);
	        PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 42);
	        Cipher cipher = Cipher.getInstance("PBEWithMD5AndDES");
	        cipher.init(Cipher.ENCRYPT_MODE, key, pbeParamSpec);
	        return cipher;
	    }
	 
	 //i actually do the encryption. the annoying thing was that i had no clue was padding was. i kept getting an error that said like the byte[] needed to be a multiple of
	 //8 long, and i had no idea why. turns out it's something called padding, which i did
	 public byte[] encryptFile(String filepath, String password) throws IOException, GeneralSecurityException{
	        byte[] decData;
	        byte[] encData;
	        File inFile = new File(filepath);
	        Cipher cipher = makeCipher(password);
	        FileInputStream inStream = new FileInputStream(inFile);
	        int blockSize = 8;
	        int paddedCount = blockSize - ((int)inFile.length()  % blockSize );
	        int padded = (int)inFile.length() + paddedCount;
	        decData = new byte[padded];
	        inStream.read(decData);
	        inStream.close();
	        for( int i = (int)inFile.length(); i < padded; ++i ) {
	            decData[i] = (byte)paddedCount;
	        }
	        encData = cipher.doFinal(decData);
	        return encData;
	    }
	 
	 //the fat bits regarding grouplayout on the bottom were generated by eclipse's windowbuider. i guess it would have been smarter to put a class inside that
	 //did all the actionlistening, but im way more used to making em for each individual button
	 private void initialize() {
		
		fc = new JFileChooser();
		fc.setCurrentDirectory(new File(System.getProperty("user.home")));
		
		frame = new JFrame();
		frame.setBounds(100, 100, 665, 465);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JPanel imageOptions = new JPanel();
		JPanel encryptionOptions = new JPanel();
		JPanel fileOptions = new JPanel();
		JPanel runOptions = new JPanel();
		image = new JPanel();
		JPanel console = new JPanel();
		
		JLabel slider = new JLabel("Add Noise:");		
		JLabel passwordLbl = new JLabel("Password:");
		JLabel algorithm = new JLabel("Algorithm:");
		JLabel lblConfirm = new JLabel("Confirm:");
		
/*MEOW*/JButton host = new JButton("Open Host Image ");
		host.setFont(new Font("Dialog", Font.BOLD, 11));
		host.addActionListener(new ActionListener() { 
			public void actionPerformed(ActionEvent arg0) { 
            	if (fc.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
            	    File selectedFile = fc.getSelectedFile();
            	    try {
            	        one = ImageIO.read(selectedFile);
            	    } catch (IOException e) {
            	    }
            	    long bytes = selectedFile.length();
            	    size1 = ByteCount(bytes);
            	    hostSize.setText(size1);    
            	    two = one;
            	    scaleImage(one);            	    
            	    noise.setValue(0);
            	}
            }});

/*MEOW*/JButton target = new JButton("Open Target Data");
		target.setFont(new Font("Dialog", Font.BOLD, 11));
		target.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) { 
            	if (fc.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
            	    File selectedFile = fc.getSelectedFile();
            	    targetdata = selectedFile.getAbsolutePath();
            	    long bytes = selectedFile.length();
            	    size2 = ByteCount(bytes);
            	    targetSize.setText(size2);
            }}});

		targetSize = new JTextField();
		this.targetSize.setEditable(false);
		hostSize = new JTextField();
		this.hostSize.setEditable(false);
		
/*MEOW*/noise = new JSlider();
		noise.addChangeListener(new ChangeListener() {
	         public void stateChanged(ChangeEvent e) {
	            offset = ((JSlider)e.getSource()).getValue();
	            addNoise();
	         }
	      });
		
		pass1 = new JPasswordField();
		pass2 = new JPasswordField();
		JComboBox<String> combo = new JComboBox<String>();
		JCheckBox verb = new JCheckBox("Verbose Output");
		
/*MEOW*/JButton go = new JButton("Go!");
		go.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) { 
            	try {
					hideCat(pass1.getText(),pass2.getText());
				} catch (IOException e) {
					e.printStackTrace();
				} catch (GeneralSecurityException e) {
					e.printStackTrace();
				}
            }});
		
/*MEOW*/JButton save = new JButton("Save");			
		save.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent arg0) { 
            	fc.setDialogTitle("Save As");   
            	if (fc.showSaveDialog(frame) == JFileChooser.APPROVE_OPTION) {
            	    File fileToSave = fc.getSelectedFile();
            	    try {
						ImageIO.write(finalp, "png", fileToSave);
					} catch (IOException e) {
						e.printStackTrace();
					}
            	}
            }});
		
		JProgressBar progress = new JProgressBar();
		capacity = new JTextField();
		output = new JTextArea();
		
		imageOptions.setBorder(new TitledBorder(new LineBorder(new Color(255, 0, 0)), "Image Options", TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));
		
		encryptionOptions.setBorder(new TitledBorder(new LineBorder(new Color(255, 0, 0)), "Encryption Options", TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));
		
		fileOptions.setBorder(new TitledBorder(new LineBorder(new Color(255, 0, 0)), "File Options", TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));
		
		runOptions.setBorder(new TitledBorder(new LineBorder(new Color(255, 0, 0)), "Run Options", TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));
		
		image.setBorder(new TitledBorder(new LineBorder(new Color(255, 0, 0)), "Image", TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));
		
		GroupLayout groupLayout = new GroupLayout(frame.getContentPane());
		groupLayout.setHorizontalGroup(
			groupLayout.createParallelGroup(Alignment.TRAILING)
				.addGroup(groupLayout.createSequentialGroup()
					.addContainerGap()
					.addGroup(groupLayout.createParallelGroup(Alignment.TRAILING)
						.addComponent(runOptions, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
						.addComponent(imageOptions, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
						.addComponent(fileOptions, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 269, Short.MAX_VALUE)
						.addComponent(encryptionOptions, Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 269, Short.MAX_VALUE))
					.addPreferredGap(ComponentPlacement.RELATED)
					.addGroup(groupLayout.createParallelGroup(Alignment.TRAILING)
						.addComponent(this.image, GroupLayout.PREFERRED_SIZE, 366, GroupLayout.PREFERRED_SIZE)
						.addComponent(console, GroupLayout.PREFERRED_SIZE, 365, GroupLayout.PREFERRED_SIZE))
					.addContainerGap())
		);
		groupLayout.setVerticalGroup(
			groupLayout.createParallelGroup(Alignment.LEADING)
				.addGroup(groupLayout.createSequentialGroup()
					.addGap(6)
					.addGroup(groupLayout.createParallelGroup(Alignment.LEADING)
						.addGroup(groupLayout.createSequentialGroup()
							.addComponent(this.image, GroupLayout.PREFERRED_SIZE, 272, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED)
							.addComponent(console, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
						.addGroup(groupLayout.createSequentialGroup()
							.addComponent(fileOptions, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED)
							.addComponent(imageOptions, GroupLayout.PREFERRED_SIZE, 86, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED)
							.addComponent(encryptionOptions, GroupLayout.PREFERRED_SIZE, 113, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED)
							.addComponent(runOptions, GroupLayout.PREFERRED_SIZE, 105, GroupLayout.PREFERRED_SIZE)))
					.addContainerGap(16, Short.MAX_VALUE))
		);
		
		capacity.setText("Capacity:");
		capacity.setEditable(false);
		capacity.setColumns(15);
		
		output.setEditable(false);
		
		this.txtSeed = new JTextField();
		this.txtSeed.setEditable(false);
		this.txtSeed.setText("Seed:");
		this.txtSeed.setColumns(10);
		GroupLayout gl_console = new GroupLayout(console);
		gl_console.setHorizontalGroup(
			gl_console.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_console.createSequentialGroup()
					.addContainerGap()
					.addGroup(gl_console.createParallelGroup(Alignment.LEADING, false)
						.addGroup(gl_console.createSequentialGroup()
							.addComponent(capacity, GroupLayout.PREFERRED_SIZE, 154, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
							.addComponent(this.txtSeed, GroupLayout.PREFERRED_SIZE, 164, GroupLayout.PREFERRED_SIZE))
						.addComponent(output, GroupLayout.PREFERRED_SIZE, 344, GroupLayout.PREFERRED_SIZE))
					.addContainerGap())
		);
		gl_console.setVerticalGroup(
			gl_console.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_console.createSequentialGroup()
					.addGroup(gl_console.createParallelGroup(Alignment.BASELINE)
						.addComponent(capacity, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
						.addComponent(this.txtSeed, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addPreferredGap(ComponentPlacement.RELATED)
					.addComponent(output, GroupLayout.DEFAULT_SIZE, 110, Short.MAX_VALUE)
					.addContainerGap())
		);
		console.setLayout(gl_console);
		runOptions.setLayout(null);	
		verb.setBounds(13, 17, 138, 23);
		runOptions.add(verb);	
		progress.setBounds(13, 76, 229, 14);
		runOptions.add(progress);	
		go.setBounds(12, 48, 111, 23);
		runOptions.add(go);
		save.setBounds(135, 47, 107, 25);
		runOptions.add(save);	
		noise.setToolTipText("");
		noise.setValue(0);
		noise.setMajorTickSpacing(1);
		noise.setMaximum(10);
		JCheckBox pixels = new JCheckBox("Show Edited Pixels");		
		GroupLayout gl_imageOptions = new GroupLayout(imageOptions);
		gl_imageOptions.setHorizontalGroup(
			gl_imageOptions.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_imageOptions.createSequentialGroup()
					.addContainerGap()
					.addGroup(gl_imageOptions.createParallelGroup(Alignment.LEADING)
						.addComponent(pixels)
						.addGroup(gl_imageOptions.createSequentialGroup()
							.addComponent(slider)
							.addPreferredGap(ComponentPlacement.UNRELATED)
							.addComponent(this.noise, GroupLayout.DEFAULT_SIZE, 141, Short.MAX_VALUE)))
					.addContainerGap())
		);
		gl_imageOptions.setVerticalGroup(
			gl_imageOptions.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_imageOptions.createSequentialGroup()
					.addContainerGap()
					.addGroup(gl_imageOptions.createParallelGroup(Alignment.TRAILING)
						.addComponent(slider)
						.addComponent(this.noise, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addPreferredGap(ComponentPlacement.RELATED, 5, Short.MAX_VALUE)
					.addComponent(pixels)
					.addContainerGap())
		);
		imageOptions.setLayout(gl_imageOptions);	
		passwordLbl.setHorizontalAlignment(SwingConstants.LEFT);	
		algorithm.setHorizontalAlignment(SwingConstants.LEFT);		
		pass1.setColumns(10);	
		combo.setModel(new DefaultComboBoxModel<String>(new String[] {"AES", "DES", "DSA", "OAEP", "RC2"}));	
		GroupLayout gl_encryptionOptions = new GroupLayout(encryptionOptions);
		gl_encryptionOptions.setHorizontalGroup(
			gl_encryptionOptions.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_encryptionOptions.createSequentialGroup()
					.addContainerGap()
					.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.LEADING)
						.addGroup(gl_encryptionOptions.createSequentialGroup()
							.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.LEADING)
								.addComponent(passwordLbl, GroupLayout.PREFERRED_SIZE, 114, GroupLayout.PREFERRED_SIZE)
								.addComponent(lblConfirm))
							.addPreferredGap(ComponentPlacement.RELATED)
							.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.LEADING)
								.addComponent(pass1, GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
								.addComponent(pass2, GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)))
						.addGroup(gl_encryptionOptions.createSequentialGroup()
							.addComponent(algorithm, GroupLayout.PREFERRED_SIZE, 114, GroupLayout.PREFERRED_SIZE)
							.addPreferredGap(ComponentPlacement.RELATED)
							.addComponent(combo, GroupLayout.PREFERRED_SIZE, 75, GroupLayout.PREFERRED_SIZE)))
					.addContainerGap())
		);
		gl_encryptionOptions.setVerticalGroup(
			gl_encryptionOptions.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_encryptionOptions.createSequentialGroup()
					.addGap(6)
					.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.BASELINE)
						.addComponent(passwordLbl, GroupLayout.PREFERRED_SIZE, 17, GroupLayout.PREFERRED_SIZE)
						.addComponent(pass1, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addPreferredGap(ComponentPlacement.RELATED)
					.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.BASELINE)
						.addComponent(lblConfirm, GroupLayout.PREFERRED_SIZE, 24, Short.MAX_VALUE)
						.addComponent(pass2, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addPreferredGap(ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
					.addGroup(gl_encryptionOptions.createParallelGroup(Alignment.BASELINE)
						.addComponent(algorithm, GroupLayout.PREFERRED_SIZE, 17, GroupLayout.PREFERRED_SIZE)
						.addComponent(combo, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addGap(30))
		);
		encryptionOptions.setLayout(gl_encryptionOptions);
		hostSize.setColumns(10);	
		targetSize.setColumns(10);
		GroupLayout gl_fileOptions = new GroupLayout(fileOptions);
		gl_fileOptions.setHorizontalGroup(
			gl_fileOptions.createParallelGroup(Alignment.TRAILING)
				.addGroup(gl_fileOptions.createSequentialGroup()
					.addContainerGap()
					.addGroup(gl_fileOptions.createParallelGroup(Alignment.LEADING, false)
						.addComponent(host, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
						.addComponent(target, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
					.addPreferredGap(ComponentPlacement.UNRELATED)
					.addGroup(gl_fileOptions.createParallelGroup(Alignment.TRAILING)
						.addComponent(this.targetSize, GroupLayout.DEFAULT_SIZE, 60, Short.MAX_VALUE)
						.addComponent(this.hostSize, GroupLayout.DEFAULT_SIZE, 60, Short.MAX_VALUE))
					.addContainerGap())
		);
		gl_fileOptions.setVerticalGroup(
			gl_fileOptions.createParallelGroup(Alignment.LEADING)
				.addGroup(gl_fileOptions.createSequentialGroup()
					.addGroup(gl_fileOptions.createParallelGroup(Alignment.BASELINE)
						.addComponent(host)
						.addComponent(this.hostSize, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addPreferredGap(ComponentPlacement.RELATED)
					.addGroup(gl_fileOptions.createParallelGroup(Alignment.BASELINE)
						.addComponent(target)
						.addComponent(this.targetSize, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
					.addGap(13))
		);
		fileOptions.setLayout(gl_fileOptions);
		frame.getContentPane().setLayout(groupLayout);
	}
}
